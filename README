PyAutomata
(c) Blaine Booher 2011
https://github.com/booherbg/PyAutomata

PyAutomata is a lightweight 1D cellular automata framework. The original files are
written in C++ as entirely object oriented and exist in automata-1.0.0 as an entirely 
independent and pure C++ project.

The engine is based off of "Automata.cpp" (c) 2008 Alex Reynolds.  Unfortunately
I don't know the contact information for Alex Reynolds.  He released the engine
under version 2.0 of the Apache License  (http://www.apache.org/licenses/LICENSE-2.0.html).  

I've added quite a bit of functionality to the original engine, as well as a few of
my own routines that are specialized for my needs. The most important difference
is the ability to grab binary chunks of data out from the latest generation for 
the purpose of encoding some kind of phenotype behavior.

The CA is also set up to run an infinite number of generations. There is a buffer
that is implemented as a wrap-around history. If the buffer is, say, 100 generations
long, the 101st generation is stored in the 0th row, overwriting the first generation.
This clean solutions allows for arbitrary generations. You can, for example, run
10,000,000 generations without running out of memory. And it's fast, too.

This project is currently in "hacking" state. No official .egg files or clean
installer. The makefile isn't in the greatest shape.


To build
--------

The easiest thing to do is simply run "python setup.py build_ext". This will take
the .cpp file (that was automatically generated with cython) and build it into a
python extension that is wrapped around the automata C++ class. Requies the
package python-setuptools

If you want to build by hand, just check out the makefile. There are two steps
needed to build the module.
1) run "cython --cplus pyAutomata.pyx". This will turn the .pyx file, which is
      the definitions for cython's interface, into a pyAutomata.cpp.
2) Run the necessary G++ commands to compile pyAutomata.cpp (along with the 
      files Automata.cpp and Automata.h which may be softlinked into automata-1.0.0/)
      into pyAutomata.so, a compiled python extension:

For me this looks like:
[blaine@macbook:~/Dropbox/src/Thesis/src/PyAutomata Mon Aug 22]
7$ make
mkdir -p build/temp.linux-x86_64-2.6/
# Create some soft links just to make sure
ln -s automata-1.0.0/Automata.cpp Automata.cpp
ln -s automata-1.0.0/Automata.h Automata.h
# convert .pyx into .cpp file
cython --cplus pyAutomata.pyx
# The following was generated based on setup.py; python setup.py build_ext --inplace
gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -fPIC -I. -I/usr/include/python2.6 -c pyAutomata.cpp -o build/temp.linux-x86_64-2.6//pyAutomata.o
gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -fPIC -I. -I/usr/include/python2.6 -c Automata.cpp -o build/temp.linux-x86_64-2.6//Automata.o
g++ -lm -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions build/temp.linux-x86_64-2.6//pyAutomata.o build/temp.linux-x86_64-2.6//Automata.o -lstdc++ -o pyAutomata.so

The cython step is not necessary unless you wish to modify pyAutomata.pyx


Previously here:
----------------

Some random thoughts and notes on cellular automata
00001000111000 is a pattern in rule 30 that causes finite state oscillatory pattern
    in other words, rule 30 is not random for all inputs, only for some obviously
    non-random inputs (like impulse 1).
